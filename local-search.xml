<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/27/JWT%E5%92%8CSESSION%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/02/27/JWT%E5%92%8CSESSION%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="JWT和SESSION的区别"><a href="#JWT和SESSION的区别" class="headerlink" title="JWT和SESSION的区别"></a>JWT和SESSION的区别</h2><h3 id="一-什么是jwt"><a href="#一-什么是jwt" class="headerlink" title="一 什么是jwt"></a>一 什么是jwt</h3><p>JWT（英文全称：JSON Web Token）是目前<strong>最流行</strong>的<strong>跨域认证解决方案</strong>。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jwt的优点：</span><br><span class="hljs-keyword">1. </span>可扩展性好<br>应用程序分布式部署的情况下，session需要做多机数据共享，通常可以存在数据库或者redis里面。而<span class="hljs-keyword">jwt不需要。</span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword">2. </span>无状态<br><span class="hljs-keyword">jwt不在服务端存储任何状态。RESTful </span>API的原则之一是无状态，发出请求时，总会返回带有参数的响应，不会产生附加影响。用户的认证状态引入这种附加影响，这破坏了这一原则。另外<span class="hljs-keyword">jwt的载荷中可以存储一些常用信息，用于交换信息，有效地使用 </span><span class="hljs-keyword">JWT，可以降低服务器查询数据库的次数。</span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword">jwt的缺点：</span><br><span class="hljs-keyword">1. </span>安全性<br>由于<span class="hljs-keyword">jwt的payload是使用base64编码的，并没有加密，因此jwt中不能存储敏感数据。而session的信息是存在服务端的，相对来说更安全。</span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword">2. </span>性能<br><span class="hljs-keyword">jwt太长。由于是无状态使用JWT，所有的数据都被放到JWT里，如果还要进行一些数据交换，那载荷会更大，经过编码之后导致jwt非常长，cookie的限制大小一般是4k，cookie很可能放不下，所以jwt一般放在local </span>storage里面。并且用户在系统中的每一次http请求都会把<span class="hljs-keyword">jwt携带在Header里面，http请求的Header可能比Body还要大。而sessionId只是很短的一个字符串，因此使用jwt的http请求比使用session的开销大得多。</span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword">3. </span>一次性<br>无状态是<span class="hljs-keyword">jwt的特点，但也导致了这个问题，jwt是一次性的。想修改里面的内容，就必须签发一个新的jwt。</span><br><span class="hljs-keyword">（1）无法废弃</span><br><span class="hljs-keyword">通过上面jwt的验证机制可以看出来，一旦签发一个jwt，在到期之前就会始终有效，无法中途废弃。例如你在payload中存储了一些信息，当信息需要更新时，则重新签发一个jwt，但是由于旧的jwt还没过期，拿着这个旧的jwt依旧可以登录，那登录后服务端从jwt中拿到的信息就是过时的。为了解决这个问题，我们就需要在服务端部署额外的逻辑，例如设置一个黑名单，一旦签发了新的jwt，那么旧的就加入黑名单（比如存到redis里面），避免被再次使用。</span><br><span class="hljs-keyword">（2）续签</span><br><span class="hljs-keyword">如果你使用jwt做会话管理，传统的cookie续签方案一般都是框架自带的，session有效期30分钟，30分钟内如果有访问，有效期被刷新至30分钟。一样的道理，要改变jwt的有效时间，就要签发新的jwt。最简单的一种方式是每次请求刷新jwt，即每个http请求都返回一个新的jwt。这个方法不仅暴力不优雅，而且每次请求都要做jwt的加密解密，会带来性能问题。另一种方法是在redis中单独为每个jwt设置过期时间，每次访问时刷新jwt的过期时间。</span><br></code></pre></td></tr></table></figure><h5 id="1-1-JWT-的工作原理"><a href="#1-1-JWT-的工作原理" class="headerlink" title="1.1  JWT 的工作原理"></a>1.1  JWT 的工作原理</h5><p>用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份。</p><p>![](........\js\web api笔记\img\30.png)</p><h5 id="1-2-JWT-的组成部分"><a href="#1-2-JWT-的组成部分" class="headerlink" title="1.2 JWT 的组成部分"></a>1.2 JWT 的组成部分</h5><p> JWT 通常由三部分组成，分别是 Header（头部）、Payload（有效荷载）、Signature（签名）</p><p>三者之间使用英文的“.”分隔，格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Header</span><span class="hljs-selector-class">.Payload</span><span class="hljs-selector-class">.Signature</span><br></code></pre></td></tr></table></figure><h5 id="1-3-JWT-的示例"><a href="#1-3-JWT-的示例" class="headerlink" title="1.3 JWT 的示例"></a>1.3 JWT 的示例</h5><p>下面是 JWT 字符串的示例：</p><p>![](........\js\web api笔记\img\31.png)</p><p>JWT 是一个很长的字符串，中间用英文的点（.）分隔成三个部分。</p><p>注意：<strong>JWT 内部是没有换行的</strong>，这里只是为了便于展示，将它写成了 3 行。</p><h5 id="1-4-JWT-的三个部分各自代表的含义"><a href="#1-4-JWT-的三个部分各自代表的含义" class="headerlink" title="1.4 JWT 的三个部分各自代表的含义"></a>1.4 JWT 的三个部分各自代表的含义</h5><p>JWT 的三个组成部分，从前到后分别是 Header、Payload、Signature。</p><ul><li><strong>Payload</strong> 部分<strong>才是真正的用户信息</strong>，它是用户信息经过加密之后生成的字符串。</li><li><strong>Header</strong> 和 Signature 是<strong>安全性相关</strong>的部分，只是为了保证 Token 的安全性</li></ul><h5 id="1-5-JWT-的使用方式"><a href="#1-5-JWT-的使用方式" class="headerlink" title="1.5 JWT 的使用方式"></a>1.5 JWT 的使用方式</h5><p>客户端收到服务器返回的 JWT 之后，通常会将它储存在 localStorage 或 sessionStorage 中。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT。推荐的做法是<strong>把 JWT 放在 HTTP 请求头的 Authorization 字段中</strong>，格式如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">Authorization:</span>Bearer <span class="hljs-params">&lt;token&gt;</span><br></code></pre></td></tr></table></figure><h5 id="1-6-安装-JWT-相关的包"><a href="#1-6-安装-JWT-相关的包" class="headerlink" title="1.6 安装 JWT 相关的包"></a>1.6 安装 JWT 相关的包</h5><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span><span class="hljs-keyword">jsonwebtoken </span>express-<span class="hljs-keyword">jwt</span><br></code></pre></td></tr></table></figure><ul><li><p>jsonwebtoken 用于生成 JWT 字符串 (服务端加密)</p></li><li><p>express-jwt 用于将 JWT 字符串解析还原成 JSON 对象 (服务端解密)</p><p>​</p></li></ul><h3 id="二-什么是SESSION"><a href="#二-什么是SESSION" class="headerlink" title="二  什么是SESSION"></a>二  什么是SESSION</h3><p>　Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p><p>　　如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。    </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">session</span>：<br>优点：<br><span class="hljs-number">1.</span><span class="hljs-keyword">session</span>的信息存储在服务端，相比于cookie就在一定程度上加大了数据的安全性；相比于jwt方便进行管理，也就是说当用户登录和主动注销，只需要添加删除对应的<span class="hljs-keyword">session</span>就可以，这样管理起来很方便。<br>缺点：<br><span class="hljs-number">1.</span><span class="hljs-keyword">session</span>存储在服务端，这就增大了服务器的开销，当用户多的情况下，服务器性能会大大降低。<br><span class="hljs-number">2.</span>因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。<br><span class="hljs-number">3.</span>用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，会限制负载均衡和集群水平拓展的能力。<br></code></pre></td></tr></table></figure><h5 id="1-了解-Session-认证的局限性"><a href="#1-了解-Session-认证的局限性" class="headerlink" title="1. 了解 Session 认证的局限性"></a>1. 了解 Session 认证的局限性</h5><p>Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。</p><ul><li>当前端请求后端接口<strong>不存在跨域问题</strong>的时候，<strong>推荐使用 Session</strong> 身份认证机制。</li><li>当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制。</li></ul><h5 id="1-2-了解-Session-的工作原理"><a href="#1-2-了解-Session-的工作原理" class="headerlink" title="1.2  了解 Session 的工作原理"></a>1.2  了解 Session 的工作原理</h5><p>![](........\js\web api笔记\img\34.png)</p><h5 id="1-3-安装-express-session-中间件"><a href="#1-3-安装-express-session-中间件" class="headerlink" title="1.3  安装 express-session 中间件"></a>1.3  安装 express-session 中间件</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> express-session<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/25/MySQL%20Workbench%20%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/02/25/MySQL%20Workbench%20%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL-Workbench-相关命令"><a href="#MySQL-Workbench-相关命令" class="headerlink" title="MySQL Workbench 相关命令"></a>MySQL Workbench 相关命令</h2><h5 id="1-从数据库中查询数据-列入表名称为users"><a href="#1-从数据库中查询数据-列入表名称为users" class="headerlink" title="1.从数据库中查询数据 列入表名称为users"></a>1.从数据库中查询数据 列入表名称为users</h5><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 表名称(users)<br></code></pre></td></tr></table></figure><h5 id="2-如需获取名为-“username”-和-“password”-的列的内容（从名为-“users”-的数据库表）语法格式如下："><a href="#2-如需获取名为-“username”-和-“password”-的列的内容（从名为-“users”-的数据库表）语法格式如下：" class="headerlink" title="2.如需获取名为 “username” 和 “password” 的列的内容（从名为 “users” 的数据库表）语法格式如下："></a>2.如需获取名为 “username” 和 “password” 的列的内容（从名为 “users” 的数据库表）语法格式如下：</h5><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> username,<span class="hljs-keyword">password</span> <span class="hljs-keyword">from</span> 表名称(users)<br></code></pre></td></tr></table></figure><h5 id="3-INSERT-INTO-语句用于向数据表中插入新的数据行，语法格式如下："><a href="#3-INSERT-INTO-语句用于向数据表中插入新的数据行，语法格式如下：" class="headerlink" title="3.INSERT INTO 语句用于向数据表中插入新的数据行，语法格式如下："></a>3.INSERT INTO 语句用于向数据表中插入新的数据行，语法格式如下：</h5><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名称(users) (username,<span class="hljs-keyword">password</span>) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;名称值&#x27;</span>,<span class="hljs-string">&#x27;数字值&#x27;</span>)<br></code></pre></td></tr></table></figure><h5 id="4-Update-语句用于修改表中的数据。语法格式如下：（将id为5的用户密码，更新为-888）"><a href="#4-Update-语句用于修改表中的数据。语法格式如下：（将id为5的用户密码，更新为-888）" class="headerlink" title="4.Update 语句用于修改表中的数据。语法格式如下：（将id为5的用户密码，更新为 888）"></a>4.Update 语句用于修改表中的数据。语法格式如下：（将id为5的用户密码，更新为 888）</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">update 表名称(users) <span class="hljs-builtin-name">set</span> <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;888&#x27;</span>  where <span class="hljs-attribute">id</span>=5<br></code></pre></td></tr></table></figure><h5 id="5-把-users-表中-id-为-2-的用户密码和用户状态，分别更新为-admin123-和-1-用户名为李华"><a href="#5-把-users-表中-id-为-2-的用户密码和用户状态，分别更新为-admin123-和-1-用户名为李华" class="headerlink" title="5.把 users 表中 id 为 2 的用户密码和用户状态，分别更新为 admin123 和 1  用户名为李华"></a>5.把 users 表中 id 为 2 的用户密码和用户状态，分别更新为 admin123 和 1  用户名为李华</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">select  表名称(users) <span class="hljs-builtin-name">set</span> <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;admin123&#x27;</span>,status=1,username=&#x27;李华&#x27; where <span class="hljs-attribute">id</span>=2<br></code></pre></td></tr></table></figure><h5 id="6-从-users-表中，删除-id-为-2-的用户，示例如下："><a href="#6-从-users-表中，删除-id-为-2-的用户，示例如下：" class="headerlink" title="6.从 users 表中，删除 id 为 2 的用户，示例如下："></a>6.从 users 表中，删除 id 为 2 的用户，示例如下：</h5><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名称(users) <span class="hljs-keyword">where</span> id=<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h5 id="7-从-users-表中，查询表中-id-为3的用户："><a href="#7-从-users-表中，查询表中-id-为3的用户：" class="headerlink" title="7.从 users 表中，查询表中 id 为3的用户："></a>7.从 users 表中，查询表中 id 为3的用户：</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select * <span class="hljs-keyword">from</span> 表名称(users) <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span>=<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h5 id="8-从-users-表中，查询表中-id-大于3的用户"><a href="#8-从-users-表中，查询表中-id-大于3的用户" class="headerlink" title="8.从 users 表中，查询表中 id 大于3的用户"></a>8.从 users 表中，查询表中 id 大于3的用户</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select * <span class="hljs-keyword">from</span> 表名称(users) <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span>&gt;<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h5 id="9-从-users-表中，查询表中-id-不为2的用户"><a href="#9-从-users-表中，查询表中-id-不为2的用户" class="headerlink" title="9.从 users 表中，查询表中 id 不为2的用户"></a>9.从 users 表中，查询表中 id 不为2的用户</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select * <span class="hljs-keyword">from</span> 表名称(users) <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span>!=<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h5 id="10-从-users-表中，查询表中id-3-5的用户"><a href="#10-从-users-表中，查询表中id-3-5的用户" class="headerlink" title="10.从 users 表中，查询表中id 3-5的用户"></a>10.从 users 表中，查询表中id 3-5的用户</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select * <span class="hljs-keyword">from</span> 表名称(users) <span class="hljs-keyword">where</span>  <span class="hljs-built_in">id</span> <span class="hljs-keyword">between</span> <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h5 id="11-从-users-表中，查询表中id大于3-且status为1-的用户"><a href="#11-从-users-表中，查询表中id大于3-且status为1-的用户" class="headerlink" title="11.从 users 表中，查询表中id大于3 且status为1 的用户"></a>11.从 users 表中，查询表中id大于3 且status为1 的用户</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select * <span class="hljs-keyword">from</span> 表名称(users)  <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span>&gt;<span class="hljs-number">3</span> <span class="hljs-keyword">and</span> status=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h5 id="12-从-users-表中，查询表中id为5-或者-username为uzi-的用户"><a href="#12-从-users-表中，查询表中id为5-或者-username为uzi-的用户" class="headerlink" title="12.从 users 表中，查询表中id为5 或者 username为uzi 的用户"></a>12.从 users 表中，查询表中id为5 或者 username为uzi 的用户</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">select * ftom 表名称(users) where <span class="hljs-attribute">id</span>=5 <span class="hljs-keyword">or</span> <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;uzi&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="13-从-users-表中，按照-status-字段进行升序排序-asc默认是升序排列-，示例如下："><a href="#13-从-users-表中，按照-status-字段进行升序排序-asc默认是升序排列-，示例如下：" class="headerlink" title="13.从 users 表中，按照 status 字段进行升序排序(asc默认是升序排列)，示例如下："></a>13.从 users 表中，按照 status 字段进行升序排序(asc默认是升序排列)，示例如下：</h5><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 表名称(users) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> status <span class="hljs-keyword">asc</span><br></code></pre></td></tr></table></figure><h5 id="14-从-users-表中，按照id-gt-2-的用户并且-status-字段进行升序降序-asc是降序排列-，示例如下："><a href="#14-从-users-表中，按照id-gt-2-的用户并且-status-字段进行升序降序-asc是降序排列-，示例如下：" class="headerlink" title="14.从 users 表中，按照id&gt;2 的用户并且 status 字段进行升序降序 (asc是降序排列)，示例如下："></a>14.从 users 表中，按照id&gt;2 的用户并且 status 字段进行升序降序 (asc是降序排列)，示例如下：</h5><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 表名称(users) <span class="hljs-keyword">where</span> id&gt;<span class="hljs-number">2</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id <span class="hljs-keyword">desc</span><br></code></pre></td></tr></table></figure><h5 id="15-从-users-表中-先按照-status-字段进行降序排序，再按照-username-的字母顺序，进行升序排序，示例如下："><a href="#15-从-users-表中-先按照-status-字段进行降序排序，再按照-username-的字母顺序，进行升序排序，示例如下：" class="headerlink" title="15.从 users 表中,先按照 status 字段进行降序排序，再按照 username 的字母顺序，进行升序排序，示例如下："></a>15.从 users 表中,先按照 status 字段进行降序排序，再按照 username 的字母顺序，进行升序排序，示例如下：</h5><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 表名称(users) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> status <span class="hljs-keyword">desc</span>,username <span class="hljs-keyword">asc</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/22/%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%EF%BC%8C%E5%88%A4%E6%96%AD%E8%BF%99%E4%B8%AA%E5%8F%98%E9%87%8F%E6%98%AF%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/02/22/%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%EF%BC%8C%E5%88%A4%E6%96%AD%E8%BF%99%E4%B8%AA%E5%8F%98%E9%87%8F%E6%98%AF%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="给定一个变量-判断这个变量-值是属于什么类型的"><a href="#给定一个变量-判断这个变量-值是属于什么类型的" class="headerlink" title="给定一个变量, 判断这个变量/值是属于什么类型的"></a>给定一个变量, 判断这个变量/值是属于什么类型的</h1><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">function</span> <span class="hljs-type">IdentifyingDataTypes</span>(data) &#123;<br>    //此处使用typeof来判断是否为object,不是则返回<br>    var <span class="hljs-keyword">type</span> = typeof data;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> !== &#x27;object&#x27;) &#123;<br>        return type<br>    &#125;<br>    //此处利用<span class="hljs-type">Object</span>.proto<span class="hljs-keyword">type</span>.toString().call()来判断数据类型<br>    //因为<span class="hljs-type">Object</span>.proto<span class="hljs-keyword">type</span>.toString().call()方法判断的结果是通常为[object ***],所以使用replace和正则进行分隔<br>    return <span class="hljs-type">Object</span>.proto<span class="hljs-keyword">type</span>.toString.call(data).replace(/^\[object (\<span class="hljs-type">S</span>+)\]$/, &#x27;$1&#x27;)<br>&#125;<br><span class="hljs-title">module</span>.exports = &#123;<br>    <span class="hljs-type">IdentifyingDataTypes</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/22/%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/02/22/%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h2><h5 id="1-优先从缓存中加载"><a href="#1-优先从缓存中加载" class="headerlink" title="1.优先从缓存中加载"></a>1.优先从缓存中加载</h5><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">模块在第一次加载后会被缓存。 这也意味着多次调用 <span class="hljs-meta">require</span>() 不会导致模块的代码被执行多次。<br><br>注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。<br></code></pre></td></tr></table></figure><h5 id="2-内置模块的加载机制"><a href="#2-内置模块的加载机制" class="headerlink" title="2.内置模块的加载机制"></a>2.内置模块的加载机制</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">内置模块是由 Node<span class="hljs-number">.</span><span class="hljs-keyword">js</span> 官方提供的模块，内置模块的加载优先级最高。<br><br>例如，require(‘<span class="hljs-built_in">fs</span>’) 始终返回内置的 <span class="hljs-built_in">fs</span> 模块，即使在 node_modules 目录下有名字相同的包也叫做 <span class="hljs-built_in">fs</span>。<br></code></pre></td></tr></table></figure><h5 id="3-自定义模块的加载机制"><a href="#3-自定义模块的加载机制" class="headerlink" title="3.自定义模块的加载机制"></a>3.自定义模块的加载机制</h5><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">使用 require<span class="hljs-params">()</span> 加载自定义模块时，必须指定以 <span class="hljs-string">./</span> 或 …/ 开头的路径标识符。在加载自定义模块时，如果没有指定 <span class="hljs-string">./</span> 或 …/ 这样的路径标识符，则 node 会把它当作内置模块或第三方模块进行加载。<br><br>同时，在使用 require<span class="hljs-params">()</span> 导入自定义模块时，如果省略了文件的扩展名，则 Node.js 会按顺序分别尝试加载以下的文件：<br><br>①按照确切的文件名进行加载<br>②补全 <span class="hljs-string">.js</span> 扩展名进行加载<br>③补全 <span class="hljs-string">.json</span> 扩展名进行加载<br>④补全 <span class="hljs-string">.node</span> 扩展名进行加载<br>⑤加载失败，终端报错<br></code></pre></td></tr></table></figure><h5 id="4-第三方模块的加载机制"><a href="#4-第三方模块的加载机制" class="headerlink" title="4.第三方模块的加载机制"></a>4.第三方模块的加载机制</h5><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">如果传递给 require() 的模块标识符不是一个内置模块，也没有以 ‘./’ 或 ‘…/’ 开头，则 Node.js 会从当前模块的父目录开始，尝试从 /node_modules 文件夹中加载第三方模块。<br><br>如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。<br><br>例如，假设在 ‘C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\i</span>theima<span class="hljs-symbol">\p</span>roject<span class="hljs-symbol">\f</span>oo.js’ 文件里调用了 require(‘tools’)，则 Node.js 会按以下顺序查找：<br><br>① C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\i</span>theima<span class="hljs-symbol">\p</span>roject<span class="hljs-symbol">\n</span>ode_modules<span class="hljs-symbol">\t</span>ools<br>② C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\i</span>theima<span class="hljs-symbol">\n</span>ode_modules<span class="hljs-symbol">\t</span>ools<br>③ C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\n</span>ode_modules<span class="hljs-symbol">\t</span>ools<br>④ C:<span class="hljs-symbol">\n</span>ode_modules<span class="hljs-symbol">\t</span>ools<br></code></pre></td></tr></table></figure><h5 id="5-目录作为模块"><a href="#5-目录作为模块" class="headerlink" title="5.目录作为模块"></a>5.目录作为模块</h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua">当把目录作为模块标识符，传递给 <span class="hljs-built_in">require</span>() 进行加载的时候，有三种加载方式：<br><br>①在被加载的目录下查找一个叫做 <span class="hljs-built_in">package</span>.json 的文件，并寻找 main 属性，作为 <span class="hljs-built_in">require</span>() 加载的入口<br><br>②如果目录里没有 <span class="hljs-built_in">package</span>.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。<br><br>③如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：Error: Cannot <span class="hljs-built_in">find</span> <span class="hljs-built_in">module</span> ‘xxx’<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/22/npm%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/02/22/npm%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="npm-相关的命令"><a href="#npm-相关的命令" class="headerlink" title="npm 相关的命令"></a>npm 相关的命令</h1><h5 id="1-查看npm的版本信息"><a href="#1-查看npm的版本信息" class="headerlink" title="1.查看npm的版本信息"></a>1.查看npm的版本信息</h5><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> -v<br></code></pre></td></tr></table></figure><h5 id="2-安装第三方包和卸载"><a href="#2-安装第三方包和卸载" class="headerlink" title="2.安装第三方包和卸载"></a>2.安装第三方包和卸载</h5><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install 包名          (会生成一个node_modules文件目录，所下载的包都放在这个目录里。)<br><span class="hljs-built_in">npm</span> install 包名@xxx      (下载指定包版本)<br><span class="hljs-built_in">npm</span> install               (一次性安装所有的依赖包)<br><span class="hljs-built_in">npm</span> init -y               (生成一个 package.json 文件 里面用来记录您使用 <span class="hljs-built_in">npm</span> install 命令安装了哪些包)<br><span class="hljs-built_in">npm</span> uninstall 包名        (卸载第三方包)<br><span class="hljs-built_in">npm</span> list                  (查看项目安装了哪些包)<br><span class="hljs-built_in">npm</span> install 包名 -D       (安装指定的包，并记录到devDependencies)<br></code></pre></td></tr></table></figure><h5 id="3-切换npm的下包镜像源"><a href="#3-切换npm的下包镜像源" class="headerlink" title="3.切换npm的下包镜像源"></a>3.切换npm的下包镜像源</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">npm <span class="hljs-built_in">config</span> <span class="hljs-built_in">get</span> <span class="hljs-title">registry</span>   <span class="hljs-params">(查看当前的下包镜像源)</span></span><br><span class="hljs-function">npm <span class="hljs-built_in">config</span> <span class="hljs-built_in">set</span> registry https:<span class="hljs-comment">//registry.npm.taobao.org/ (更改 npm 的下载镜像源为淘宝镜像)</span></span><br></code></pre></td></tr></table></figure><h5 id="4-nrm"><a href="#4-nrm" class="headerlink" title="4.nrm"></a>4.nrm</h5><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">npm</span> <span class="hljs-selector-tag">i</span> <span class="hljs-selector-tag">nrm</span> <span class="hljs-selector-tag">-g</span>              (通过npm 包管理器，将 nrm 安装为全局可用的工具)<br><span class="hljs-selector-tag">nrm</span> <span class="hljs-selector-tag">ls</span>                    (查看所有可用的镜像源)<br><span class="hljs-selector-tag">nrm</span> <span class="hljs-selector-tag">use</span> <span class="hljs-selector-tag">taobao</span>            (将下包的镜像源切为 taobao 镜像) <br></code></pre></td></tr></table></figure><h5 id="5-项目包"><a href="#5-项目包" class="headerlink" title="5.项目包"></a>5.项目包</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> 包名 -D       (开发依赖包:会被记录到 devDependencies 节点中的包，只在开发期间会用到)<br>npm <span class="hljs-keyword">install</span> 包名          (核心依赖包:被记录到 dependencies 节点中的包，在开发期间和项目上线之后都会用到)<br></code></pre></td></tr></table></figure><p>6.全局包</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install 包名 -g      (全局安装指定的包)<br><span class="hljs-built_in">npm</span> uninstall 包名 -g    (卸载全局安装的包)<br></code></pre></td></tr></table></figure><h5 id="7-i5ting-toc"><a href="#7-i5ting-toc" class="headerlink" title="7.i5ting_toc"></a>7.i5ting_toc</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> install -g i<span class="hljs-number">5</span>ting_toc            (将i<span class="hljs-number">5</span>ting_toc安装为全局包)<br><span class="hljs-attribute">i5ting_toc</span> -f 要转换的md文件路径 -o   (调用i<span class="hljs-number">5</span>ting_toc，轻松实现md转html的功能)<br></code></pre></td></tr></table></figure><h5 id="8-登录"><a href="#8-登录" class="headerlink" title="8.登录"></a>8.登录</h5><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> login<br></code></pre></td></tr></table></figure><h5 id="9-发布包："><a href="#9-发布包：" class="headerlink" title="9.发布包："></a>9.发布包：</h5><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> init<br><span class="hljs-built_in">npm</span> publish<br></code></pre></td></tr></table></figure><h5 id="10-撤销发布"><a href="#10-撤销发布" class="headerlink" title="10.撤销发布"></a>10.撤销发布</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">npm -f unpublish <span class="hljs-symbol">dollarphajax@</span>*<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
